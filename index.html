<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouldering Competition Score Tracker</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        overflow-x: auto;
        min-width: 100%;
      }
      .container {
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        min-width: fit-content;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      .table-wrapper {
        overflow-x: auto;
        margin: 0 -20px;
        padding: 0 20px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .add-competitor {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .add-competitor input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        flex: 1;
        max-width: 300px;
        min-width: 150px;
      }
      .add-competitor input:invalid {
        border-color: #f44336;
      }
      .add-competitor button {
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .add-competitor button:hover {
        background: #45a049;
      }
      .add-competitor button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .error-message {
        color: #f44336;
        font-size: 12px;
        margin-top: 5px;
        display: none;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        min-width: 800px;
      }
      th,
      td {
        padding: 8px 6px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        white-space: nowrap;
        vertical-align: top;
      }
      th {
        background-color: #f8f9fa;
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .boulder-section {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        white-space: nowrap;
        padding: 0;
      }
      .boulder-controls {
        display: flex;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
      }
      .boulder-row {
        display: flex;
        gap: 6px;
        align-items: center;
        font-size: 12px;
      }
      .boulder-row .ternary-button {
        min-width: 50px;
        font-size: 11px;
      }

      .ternary-button {
        width: 50px;
        height: 26px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 4px;
        font-size: 11px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2px;
        transition: all 0.2s ease;
      }
      .ternary-button:hover {
        background: #f0f0f0;
      }
      .ternary-button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .ternary-button.success {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }
      .ternary-button.failed {
        background: #f44336;
        color: white;
        border-color: #f44336;
      }
      .attempts-control {
        display: flex;
        align-items: center;
        gap: 3px;
      }
      .attempts-control button {
        width: 20px;
        height: 20px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 3px;
        font-size: 14px;
        line-height: 1;
        padding: 0;
        transition: background-color 0.2s ease;
      }
      .attempts-control button:hover {
        background: #f0f0f0;
      }
      .attempts-control button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .attempts-control input {
        width: 32px;
        text-align: center;
        border: 1px solid #ddd;
        border-radius: 3px;
        padding: 2px;
        font-size: 12px;
      }
      .attempts-control input:invalid {
        border-color: #f44336;
      }
      .score {
        font-weight: bold;
        font-size: 12px;
        color: #666;
        margin-top: 2px;
        text-align: left;
      }
      .total-score {
        font-weight: bold;
        font-size: 16px;
        color: #333;
      }
      .position {
        font-weight: bold;
        font-size: 18px;
      }
      .position-1 {
        color: #ffd700;
      }
      .position-2 {
        color: #c0c0c0;
      }
      .position-3 {
        color: #cd7f32;
      }
      .remove-btn {
        background: #f44336;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s ease;
      }
      .remove-btn:hover {
        background: #da190b;
      }
      .remove-btn:focus {
        outline: 2px solid #f44336;
        outline-offset: 2px;
      }
      .loading {
        opacity: 0.6;
        pointer-events: none;
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .container {
          padding: 15px;
          border-radius: 4px;
          min-width: calc(100vw - 20px);
        }
        .table-wrapper {
          margin: 0 -15px;
          padding: 0 15px;
        }
        table {
          font-size: 12px;
        }
        th,
        td {
          padding: 6px 3px;
        }
        .boulder-controls {
          gap: 4px;
        }
        .boulder-row {
          gap: 5px;
        }
        .add-competitor input {
          min-width: 120px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ§— Bouldering Competition Score Tracker</h1>

      <div class="add-competitor">
        <input
          type="text"
          id="competitorName"
          placeholder="Enter competitor name"
          maxlength="50"
          aria-label="Competitor name"
          autocomplete="off"
        />
        <button
          onclick="addCompetitor()"
          id="addButton"
          aria-label="Add competitor"
        >
          Add Competitor
        </button>
        <span
          id="competitorCount"
          style="margin-left: 10px; color: #666"
          aria-live="polite"
          >0 competitors</span
        >
      </div>
      <div
        class="error-message"
        id="errorMessage"
        role="alert"
        aria-live="polite"
      ></div>

      <div style="margin: 20px 0">
        <button
          onclick="showPodiumAnalysis()"
          style="
            padding: 10px 20px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
          "
          aria-label="Analyze podium chances"
          onmouseover="this.style.background='#1976d2'"
          onmouseout="this.style.background='#2196f3'"
        >
          ðŸ“Š Analyze Podium Chances
        </button>
      </div>

      <div
        id="podiumAnalysis"
        style="
          display: none;
          margin: 20px 0;
          padding: 20px;
          background: #f8f9fa;
          border-radius: 8px;
        "
        role="region"
        aria-labelledby="analysisTitle"
      >
        <h2 id="analysisTitle" style="margin-top: 0">Podium Analysis</h2>
        <div id="analysisContent"></div>
      </div>

      <div class="table-wrapper">
        <table id="scoreTable" role="table" aria-label="Competition scores">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Boulder 1</th>
              <th scope="col">Boulder 2</th>
              <th scope="col">Boulder 3</th>
              <th scope="col">Boulder 4</th>
              <th scope="col">Total</th>
              <th scope="col">Action</th>
            </tr>
          </thead>
          <tbody id="competitorsList"></tbody>
        </table>
      </div>

      <div
        style="
          margin-top: 30px;
          padding-top: 20px;
          border-top: 1px solid #ddd;
          text-align: center;
        "
      >
        <button
          onclick="loadCompData1()"
          style="
            padding: 10px 20px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
          "
          aria-label="Load test competition data"
          onmouseover="this.style.background='#f57c00'"
          onmouseout="this.style.background='#ff9800'"
        >
          CompData1
        </button>
      </div>
    </div>

    <script>
      let competitors = [];
      let competitorId = 0;
      let isUpdating = false;
      const MAX_COMPETITORS = 50;
      const MAX_ATTEMPTS = 50;
      const DECIMAL_PRECISION = 1;

      // Scoring constants
      const TOP_SCORE = 25; // Points awarded for completing a boulder (top)
      const ZONE_SCORE = 10; // Points awarded for reaching the zone
      const ATTEMPT_DEDUCTION = 0.1; // Points deducted per additional attempt

      // Utility functions
      function sanitizeInput(input) {
        return input.trim().replace(/[<>'"&]/g, "");
      }

      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function validateCompetitorName(name) {
        if (!name || name.length === 0) {
          return "Please enter a competitor name";
        }
        if (name.length > 50) {
          return "Name must be 50 characters or less";
        }
        if (
          competitors.some((c) => c.name.toLowerCase() === name.toLowerCase())
        ) {
          return "A competitor with this name already exists";
        }
        return null;
      }

      function addCompetitor() {
        const nameInput = document.getElementById("competitorName");
        const name = sanitizeInput(nameInput.value);

        const validationError = validateCompetitorName(name);
        if (validationError) {
          showError(validationError);
          nameInput.focus();
          return;
        }

        if (competitors.length >= MAX_COMPETITORS) {
          showError(`Maximum ${MAX_COMPETITORS} competitors allowed`);
          return;
        }

        const competitor = {
          id: competitorId++,
          name: name,
          boulders: Array(4)
            .fill(null)
            .map(() => ({
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            })),
        };

        competitors.push(competitor);
        nameInput.value = "";
        updateDisplay();

        // Update button state
        if (competitors.length >= MAX_COMPETITORS) {
          document.getElementById("addButton").disabled = true;
        }

        // Announce to screen readers
        const announcement = `Added competitor ${name}. Total: ${competitors.length} competitors.`;
        announceToScreenReader(announcement);
      }

      function removeCompetitor(id) {
        const competitor = competitors.find((c) => c.id === id);
        if (!competitor) return;

        if (confirm(`Are you sure you want to remove ${competitor.name}?`)) {
          competitors = competitors.filter((c) => c.id !== id);
          updateDisplay();
          document.getElementById("addButton").disabled = false;

          // Announce to screen readers
          announceToScreenReader(`Removed competitor ${competitor.name}`);
        }
      }

      function updateZone(competitorId, boulderIndex) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        // Cycle through: null (not attempted) -> true (achieved) -> false (failed) -> null
        if (boulder.zone === null) {
          boulder.zone = true;
          boulder.attempted = true;
        } else if (boulder.zone === true) {
          boulder.zone = false;
          // If zone failed, top cannot be achieved
          if (boulder.top) {
            boulder.top = false;
          }
        } else {
          boulder.zone = null;
          boulder.attempted = false;
          boulder.top = false;
          boulder.zoneAttempts = 1; // Reset attempts when not attempted
          boulder.topAttempts = 1;
        }

        debouncedUpdateDisplay();
      }

      function updateTop(competitorId, boulderIndex) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        // Toggle between false and true (only two states)
        boulder.top = !boulder.top;
        boulder.attempted = true;

        // If checking top, zone must be achieved (logical consistency)
        if (boulder.top) {
          boulder.zone = true;
          // Ensure topAttempts >= zoneAttempts
          if (boulder.topAttempts < boulder.zoneAttempts) {
            boulder.topAttempts = boulder.zoneAttempts;
          }
        }

        debouncedUpdateDisplay();
      }

      function updateZoneAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Zone attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        const boulder = competitor.boulders[boulderIndex];
        boulder.zoneAttempts = attempts;

        // Zone attempts automatically set the minimum for top attempts
        // (since all attempts to reach zone are also attempts toward the top)
        if (boulder.topAttempts < attempts) {
          boulder.topAttempts = attempts;
        }

        debouncedUpdateDisplay();
      }

      function changeZoneAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        const newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.zoneAttempts + delta)
        );
        boulder.zoneAttempts = newAttempts;

        // Zone attempts automatically set the minimum for top attempts
        // (since all attempts to reach zone are also attempts toward the top)
        if (boulder.topAttempts < newAttempts) {
          boulder.topAttempts = newAttempts;
        }

        debouncedUpdateDisplay();
      }

      function updateTopAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Top attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        const boulder = competitor.boulders[boulderIndex];

        // If zone is achieved, ensure topAttempts >= zoneAttempts
        if (boulder.zone === true && attempts < boulder.zoneAttempts) {
          showError(
            `Top attempts (${attempts}) cannot be less than zone attempts (${boulder.zoneAttempts})`
          );
          return;
        }

        boulder.topAttempts = attempts;
        debouncedUpdateDisplay();
      }

      function changeTopAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        let newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.topAttempts + delta)
        );

        // If zone is achieved, ensure topAttempts >= zoneAttempts
        if (boulder.zone === true) {
          newAttempts = Math.max(newAttempts, boulder.zoneAttempts);
        }

        boulder.topAttempts = newAttempts;
        debouncedUpdateDisplay();
      }

      function calculateBoulderScore(boulder) {
        // Migrate old format if needed
        if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
          boulder.zoneAttempts = boulder.attempts;
          boulder.topAttempts = boulder.attempts;
          delete boulder.attempts;
        }

        if (!boulder.attempted || boulder.zone === null) return 0;
        if (boulder.zone === false && !boulder.top) return 0; // Failed

        let score = 0;
        let attemptsToDeduct = 0;

        if (boulder.top) {
          score = TOP_SCORE;
          attemptsToDeduct = boulder.topAttempts;
        } else if (boulder.zone === true) {
          score = ZONE_SCORE;
          attemptsToDeduct = boulder.zoneAttempts;
        }

        // Deduct ATTEMPT_DEDUCTION for each attempt after the first
        const deduction = (attemptsToDeduct - 1) * ATTEMPT_DEDUCTION;
        return Math.max(0, Math.round((score - deduction) * 10) / 10); // Round to 1 decimal place
      }

      function calculateTotalScore(competitor) {
        const total = competitor.boulders.reduce((sum, boulder) => {
          return sum + calculateBoulderScore(boulder);
        }, 0);
        return Math.round(total * 10) / 10; // Round to 1 decimal place
      }

      function updateDisplay() {
        if (isUpdating) return;
        isUpdating = true;

        const tbody = document.getElementById("competitorsList");
        const competitorCount = document.getElementById("competitorCount");
        const container = document.querySelector(".container");

        // Show loading state
        container.classList.add("loading");

        // Update competitor count
        competitorCount.textContent = `${competitors.length} competitor${
          competitors.length !== 1 ? "s" : ""
        }`;

        // Calculate scores but keep original order
        const competitorsWithScores = competitors.map((c) => ({
          ...c,
          totalScore: calculateTotalScore(c),
        }));

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();

        // Add rows for each competitor in original order
        competitorsWithScores.forEach((competitor, index) => {
          const row = document.createElement("tr");
          row.setAttribute("data-competitor-id", competitor.id);

          // Show row number instead of position
          const posCell = document.createElement("td");
          posCell.textContent = index + 1;
          row.appendChild(posCell);

          // Name
          const nameCell = document.createElement("td");
          nameCell.textContent = competitor.name;
          nameCell.setAttribute("data-label", "Name");
          row.appendChild(nameCell);

          // Boulders
          for (let i = 0; i < 4; i++) {
            const boulder = competitor.boulders[i];
            const boulderCell = document.createElement("td");
            boulderCell.setAttribute("data-label", `Boulder ${i + 1}`);

            const boulderSection = document.createElement("div");
            boulderSection.className = "boulder-section";

            const controls = document.createElement("div");
            controls.className = "boulder-controls";

            // Migrate old format if needed
            if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
              boulder.zoneAttempts = boulder.attempts;
              boulder.topAttempts = boulder.attempts;
              delete boulder.attempts;
            }

            // Zone row
            const zoneRow = document.createElement("div");
            zoneRow.className = "boulder-row";

            // Zone ternary button
            const zoneButton = document.createElement("button");
            zoneButton.className = "ternary-button";
            zoneButton.setAttribute(
              "aria-label",
              `Toggle zone status for boulder ${i + 1}`
            );
            zoneButton.setAttribute("tabindex", "0");

            if (boulder.zone === true) {
              zoneButton.className += " success";
              zoneButton.setAttribute("aria-pressed", "true");
            } else if (boulder.zone === false) {
              zoneButton.className += " failed";
              zoneButton.setAttribute("aria-pressed", "false");
            } else {
              zoneButton.setAttribute("aria-pressed", "mixed");
            }

            zoneButton.textContent = "Zone";
            zoneButton.onclick = () => updateZone(competitor.id, i);
            zoneButton.onkeydown = (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                updateZone(competitor.id, i);
              }
            };

            // Zone attempts control
            const zoneAttemptsControl = document.createElement("div");
            zoneAttemptsControl.className = "attempts-control";
            zoneAttemptsControl.setAttribute("role", "group");
            zoneAttemptsControl.setAttribute(
              "aria-label",
              `Attempts to achieve zone for boulder ${i + 1}`
            );

            const zoneMinusBtn = document.createElement("button");
            zoneMinusBtn.textContent = "-";
            zoneMinusBtn.setAttribute(
              "aria-label",
              "Decrease attempts to achieve zone"
            );
            zoneMinusBtn.onclick = () =>
              changeZoneAttempts(competitor.id, i, -1);

            const zoneAttemptsInput = document.createElement("input");
            zoneAttemptsInput.type = "number";
            zoneAttemptsInput.min = "1";
            zoneAttemptsInput.max = MAX_ATTEMPTS.toString();
            zoneAttemptsInput.value = boulder.zoneAttempts;
            zoneAttemptsInput.setAttribute(
              "aria-label",
              `Number of attempts to achieve zone for boulder ${i + 1}`
            );
            zoneAttemptsInput.onchange = (e) =>
              updateZoneAttempts(competitor.id, i, e.target.value);

            const zonePlusBtn = document.createElement("button");
            zonePlusBtn.textContent = "+";
            zonePlusBtn.setAttribute(
              "aria-label",
              "Increase attempts to achieve zone"
            );
            zonePlusBtn.onclick = () => changeZoneAttempts(competitor.id, i, 1);

            zoneAttemptsControl.appendChild(zoneMinusBtn);
            zoneAttemptsControl.appendChild(zoneAttemptsInput);
            zoneAttemptsControl.appendChild(zonePlusBtn);

            zoneRow.appendChild(zoneButton);
            zoneRow.appendChild(zoneAttemptsControl);

            // Top row
            const topRow = document.createElement("div");
            topRow.className = "boulder-row";

            // Top toggle button
            const topButton = document.createElement("button");
            topButton.className = "ternary-button";
            topButton.setAttribute(
              "aria-label",
              `Toggle top status for boulder ${i + 1}`
            );
            topButton.setAttribute("tabindex", "0");

            if (boulder.top) {
              topButton.className += " success";
              topButton.setAttribute("aria-pressed", "true");
            } else {
              topButton.setAttribute("aria-pressed", "false");
            }

            topButton.textContent = "Top";
            topButton.onclick = () => updateTop(competitor.id, i);
            topButton.onkeydown = (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                updateTop(competitor.id, i);
              }
            };

            // Top attempts control
            const topAttemptsControl = document.createElement("div");
            topAttemptsControl.className = "attempts-control";
            topAttemptsControl.setAttribute("role", "group");
            topAttemptsControl.setAttribute(
              "aria-label",
              `Total attempts to achieve top for boulder ${i + 1}`
            );

            const topMinusBtn = document.createElement("button");
            topMinusBtn.textContent = "-";
            topMinusBtn.setAttribute(
              "aria-label",
              "Decrease total attempts to achieve top"
            );
            topMinusBtn.onclick = () => changeTopAttempts(competitor.id, i, -1);

            const topAttemptsInput = document.createElement("input");
            topAttemptsInput.type = "number";
            topAttemptsInput.min = "1";
            topAttemptsInput.max = MAX_ATTEMPTS.toString();
            topAttemptsInput.value = boulder.topAttempts;
            topAttemptsInput.setAttribute(
              "aria-label",
              `Total number of attempts to achieve top for boulder ${i + 1}`
            );
            topAttemptsInput.onchange = (e) =>
              updateTopAttempts(competitor.id, i, e.target.value);

            const topPlusBtn = document.createElement("button");
            topPlusBtn.textContent = "+";
            topPlusBtn.setAttribute(
              "aria-label",
              "Increase total attempts to achieve top"
            );
            topPlusBtn.onclick = () => changeTopAttempts(competitor.id, i, 1);

            topAttemptsControl.appendChild(topMinusBtn);
            topAttemptsControl.appendChild(topAttemptsInput);
            topAttemptsControl.appendChild(topPlusBtn);

            topRow.appendChild(topButton);
            topRow.appendChild(topAttemptsControl);

            controls.appendChild(zoneRow);
            controls.appendChild(topRow);
            boulderSection.appendChild(controls);

            // Score display
            const score = calculateBoulderScore(boulder);
            const scoreDiv = document.createElement("div");
            scoreDiv.className = "score";
            scoreDiv.textContent = `Score: ${score.toFixed(1)}`;
            scoreDiv.setAttribute(
              "aria-label",
              `Boulder ${i + 1} score: ${score.toFixed(1)} points`
            );
            boulderSection.appendChild(scoreDiv);

            boulderCell.appendChild(boulderSection);
            row.appendChild(boulderCell);
          }

          // Total score
          const totalCell = document.createElement("td");
          totalCell.setAttribute("data-label", "Total");
          totalCell.innerHTML = `<span class="total-score">${competitor.totalScore.toFixed(
            1
          )}</span>`;
          totalCell.setAttribute(
            "aria-label",
            `Total score: ${competitor.totalScore.toFixed(1)} points`
          );
          row.appendChild(totalCell);

          // Remove button
          const actionCell = document.createElement("td");
          actionCell.setAttribute("data-label", "Action");
          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-btn";
          removeBtn.textContent = "Remove";
          removeBtn.setAttribute(
            "aria-label",
            `Remove competitor ${competitor.name}`
          );
          removeBtn.onclick = () => removeCompetitor(competitor.id);
          actionCell.appendChild(removeBtn);
          row.appendChild(actionCell);

          fragment.appendChild(row);
        });

        // Clear and update tbody
        tbody.innerHTML = "";
        tbody.appendChild(fragment);

        // Remove loading state
        container.classList.remove("loading");
        isUpdating = false;
      }

      // Debounced version of updateDisplay for better performance
      const debouncedUpdateDisplay = debounce(updateDisplay, 100);

      function announceToScreenReader(message) {
        const announcement = document.createElement("div");
        announcement.setAttribute("aria-live", "polite");
        announcement.setAttribute("aria-atomic", "true");
        announcement.style.position = "absolute";
        announcement.style.left = "-9999px";
        announcement.textContent = message;
        document.body.appendChild(announcement);
        setTimeout(() => document.body.removeChild(announcement), 1000);
      }

      // Allow Enter key to add competitor
      document
        .getElementById("competitorName")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            addCompetitor();
          }
        });

      // Load test competition data
      function loadCompData1() {
        // Clear existing competitors
        competitors = [];
        competitorId = 0;

        // Create Shem's data
        const shem = {
          id: competitorId++,
          name: "Shem",
          boulders: [
            // B1: Z3,T4 - Zone on 3rd attempt, Top on 4th attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 3,
              topAttempts: 4,
              attempted: true,
            },
            // B2: Z1,T2 - Zone on 1st attempt, Top on 2nd attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 2,
              attempted: true,
            },
            // B3: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: Z6,T10 - Zone on 6th attempt, Top on 10th attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 6,
              topAttempts: 10,
              attempted: true,
            },
          ],
        };

        // Create Mark's data
        const mark = {
          id: competitorId++,
          name: "Mark",
          boulders: [
            // B1: 5,5 - Attempted 5 times, no zone or top
            {
              zone: false,
              top: false,
              zoneAttempts: 5,
              topAttempts: 5,
              attempted: true,
            },
            // B2: Z10,15 - Zone on 10th attempt, attempted top 15 times but didn't get it
            {
              zone: true,
              top: false,
              zoneAttempts: 10,
              topAttempts: 15,
              attempted: true,
            },
            // B3: Z10,10 - Zone on 10th attempt, attempted 10 times total
            {
              zone: true,
              top: false,
              zoneAttempts: 10,
              topAttempts: 10,
              attempted: true,
            },
            // B4: Not attempted yet
            {
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            },
          ],
        };

        // Create Lukas's data
        const lukas = {
          id: competitorId++,
          name: "Lukas",
          boulders: [
            // B1: Z7,7 - Zone on 7th attempt, attempted 7 times total
            {
              zone: true,
              top: false,
              zoneAttempts: 7,
              topAttempts: 7,
              attempted: true,
            },
            // B2: 7,7 - Attempted 7 times, no zone or top
            {
              zone: false,
              top: false,
              zoneAttempts: 7,
              topAttempts: 7,
              attempted: true,
            },
            // B3: Z1,1 - Zone on 1st attempt, attempted 1 time total
            {
              zone: true,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: Not attempted yet
            {
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            },
          ],
        };

        // Create Erica's data
        const erica = {
          id: competitorId++,
          name: "Erica",
          boulders: [
            // B1: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B2: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B3: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: Not attempted yet
            {
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            },
          ],
        };

        // Create Davance's data
        const davance = {
          id: competitorId++,
          name: "Davance",
          boulders: [
            // B1: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B2: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B3: Z1,T6 - Zone on 1st attempt, Top on 6th attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 6,
              attempted: true,
            },
            // B4: Not attempted yet
            {
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            },
          ],
        };

        // Create Lily's data
        const lily = {
          id: competitorId++,
          name: "Lily",
          boulders: [
            // B1: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B2: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B3: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: Z3,10 - Zone on 3rd attempt, attempted top 10 times but didn't get it
            {
              zone: true,
              top: false,
              zoneAttempts: 3,
              topAttempts: 10,
              attempted: true,
            },
          ],
        };

        // Create Megan's data
        const megan = {
          id: competitorId++,
          name: "Megan",
          boulders: [
            // B1: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B2: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B3: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: 3,10 - Attempted zone 3 times (failed), attempted top 10 times (failed)
            {
              zone: false,
              top: false,
              zoneAttempts: 3,
              topAttempts: 10,
              attempted: true,
            },
          ],
        };

        // Create MM's data
        const mm = {
          id: competitorId++,
          name: "MM",
          boulders: [
            // B1: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B2: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B3: Z1,T1 - Zone on 1st attempt, Top on 1st attempt
            {
              zone: true,
              top: true,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: true,
            },
            // B4: 10,10 - Attempted 10 times, no zone or top
            {
              zone: false,
              top: false,
              zoneAttempts: 10,
              topAttempts: 10,
              attempted: true,
            },
          ],
        };

        // Add competitors to the list
        competitors.push(shem, mark, lukas, erica, davance, lily, megan, mm);

        // Update display and enable add button
        updateDisplay();
        document.getElementById("addButton").disabled = false;

        // Announce to screen readers
        announceToScreenReader(
          "Test competition data loaded: 8 competitors added"
        );
      }

      function showPodiumAnalysis() {
        const analysisDiv = document.getElementById("podiumAnalysis");
        const content = document.getElementById("analysisContent");

        if (competitors.length === 0) {
          showError("Please add competitors first");
          return;
        }

        // Toggle display
        if (analysisDiv.style.display === "none") {
          analysisDiv.style.display = "block";
          content.innerHTML = generatePodiumAnalysis();
        } else {
          analysisDiv.style.display = "none";
        }
      }

      function generatePodiumAnalysis() {
        try {
          // Calculate current scores and standings
          const competitorAnalysis = competitors.map((c) => {
            const currentScore = calculateTotalScore(c);
            const unattemptedBoulders = c.boulders.filter((b) => !b.attempted);
            const remainingBoulders = unattemptedBoulders.length;
            const maxPossibleScore =
              currentScore + remainingBoulders * TOP_SCORE;
            const isFinished = remainingBoulders === 0;

            return {
              ...c,
              currentScore,
              remainingBoulders,
              unattemptedBoulders,
              maxPossibleScore,
              isFinished,
            };
          });

          // Sort by current score to determine standings
          const currentStandings = [...competitorAnalysis].sort(
            (a, b) => b.currentScore - a.currentScore
          );

          // Calculate positions with proper tie handling
          let currentPosition = 1;
          let previousScore = null;
          let tiedCount = 0;

          currentStandings.forEach((comp) => {
            if (
              previousScore !== null &&
              Math.abs(comp.currentScore - previousScore) > 0.01
            ) {
              currentPosition += tiedCount;
              tiedCount = 1;
            } else {
              tiedCount++;
            }
            comp.currentPosition = currentPosition;
            previousScore = comp.currentScore;
          });

          // Update original analysis array with positions
          competitorAnalysis.forEach((comp) => {
            const standingComp = currentStandings.find((c) => c.id === comp.id);
            comp.currentPosition = standingComp.currentPosition;
          });

          let html = "";

          // Sort by current position for display
          const sortedByPosition = [...competitorAnalysis].sort(
            (a, b) => a.currentPosition - b.currentPosition
          );

          sortedByPosition.forEach((competitor) => {
            const analysis = analyzePodiumChances(
              competitor,
              competitorAnalysis
            );

            // Format position text with tie handling
            const competitorsAtSameScore = competitorAnalysis.filter(
              (c) => Math.abs(c.currentScore - competitor.currentScore) < 0.01
            ).length;

            const positionSuffix = getPositionSuffix(
              competitor.currentPosition
            );
            let positionText;
            if (competitorsAtSameScore > 1) {
              positionText = `tied for ${competitor.currentPosition}${positionSuffix} place`;
            } else {
              positionText = `${competitor.currentPosition}${positionSuffix} place`;
            }

            html += `<div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 4px; border: 1px solid #ddd;">`;
            html += `<h3 style="margin-top: 0; color: #333;">${
              competitor.name
            } - Currently ${positionText} (${competitor.currentScore.toFixed(
              1
            )} points)</h3>`;

            html += `<div style="margin-left: 10px;">`;
            analysis.forEach((message) => {
              html += `<p style="margin: 5px 0; color: #555;">â€¢ ${message}</p>`;
            });
            html += `</div>`;

            html += `</div>`;
          });

          return html;
        } catch (error) {
          console.error("Error generating podium analysis:", error);
          return `<p style="color: #f44336;">Error generating analysis. Please try again.</p>`;
        }
      }

      function analyzePodiumChances(competitor, allCompetitors) {
        const messages = [];

        // Case 1: Competitor has finished all boulders
        if (competitor.isFinished) {
          messages.push(
            `All boulders completed - Final score: ${competitor.currentScore.toFixed(
              1
            )} points`
          );
          return messages;
        }

        // Case 2: Check if podium is mathematically possible
        if (competitor.maxPossibleScore < getPodiumThreshold(allCompetitors)) {
          messages.push(
            `Cannot reach podium (max possible: ${competitor.maxPossibleScore.toFixed(
              1
            )} points)`
          );
          return messages;
        }

        // Case 3: Analyze requirements for each podium position
        const podiumRequirements = calculatePodiumRequirements(
          competitor,
          allCompetitors
        );

        if (podiumRequirements.length === 0) {
          messages.push(
            "No podium improvements possible with remaining boulders"
          );
        } else {
          podiumRequirements.forEach((req) => messages.push(req));
        }

        return messages;
      }

      function calculatePodiumRequirements(competitor, allCompetitors) {
        const requirements = [];
        const unattemptedBoulders = competitor.boulders
          .map((b, idx) => ({ boulder: b, index: idx }))
          .filter((item) => !item.boulder.attempted);

        // Get current podium holders and their scores
        const podiumHolders = getPodiumHolders(allCompetitors);

        // Check requirements for each position (1st, 2nd, 3rd)
        for (let targetPosition = 1; targetPosition <= 3; targetPosition++) {
          if (targetPosition >= competitor.currentPosition) continue; // Only improvements

          const positionRequirements = [];

          // Check each unattempted boulder
          unattemptedBoulders.forEach((item) => {
            const boulderReqs = getBoulderRequirements(
              competitor,
              item,
              targetPosition,
              podiumHolders,
              allCompetitors
            );
            positionRequirements.push(...boulderReqs);
          });

          // Add requirements for this position if any exist
          if (positionRequirements.length > 0) {
            const positionName = getPositionName(targetPosition);
            const bestReq = positionRequirements[0]; // Take the first/best option

            let competitionNote = "";
            const potentialCompetitors = allCompetitors.filter(
              (c) =>
                c.id !== competitor.id &&
                !c.isFinished &&
                c.maxPossibleScore >= podiumHolders[targetPosition - 1]?.score
            );

            if (potentialCompetitors.length > 0) {
              const competitorNames = potentialCompetitors
                .map((c) => c.name)
                .join(", ");
              competitionNote = ` (and also beat: ${competitorNames})`;
            }

            requirements.push(
              `For ${positionName}: ${bestReq}${competitionNote}`
            );
          }
        }

        return requirements;
      }

      function getBoulderRequirements(
        competitor,
        boulderItem,
        targetPosition,
        podiumHolders,
        allCompetitors
      ) {
        const requirements = [];
        const targetScore = podiumHolders[targetPosition - 1]?.score || 0;

        // Check Zone requirement first (easier option)
        const maxZoneAttempts = Math.floor(
          (competitor.currentScore + ZONE_SCORE - targetScore) /
            ATTEMPT_DEDUCTION +
            1
        );

        if (
          maxZoneAttempts >= 1 &&
          competitor.currentScore + ZONE_SCORE >= targetScore
        ) {
          // Show zone option if it can achieve the target position
          if (maxZoneAttempts > 50) {
            requirements.push(`Zone Boulder ${boulderItem.index + 1}`);
          } else {
            const zoneAttemptText =
              maxZoneAttempts === 1
                ? " within 1 attempt"
                : ` within ${maxZoneAttempts} attempts`;
            requirements.push(
              `Zone Boulder ${boulderItem.index + 1}${zoneAttemptText}`
            );
          }
        }

        // Check Top requirement (harder option, only if zone can't achieve target)
        const maxTopAttempts = Math.floor(
          (competitor.currentScore + TOP_SCORE - targetScore) /
            ATTEMPT_DEDUCTION +
            1
        );

        if (
          maxTopAttempts >= 1 &&
          competitor.currentScore + ZONE_SCORE < targetScore
        ) {
          if (maxTopAttempts <= 50) {
            const attemptText =
              maxTopAttempts === 1
                ? " within 1 attempt"
                : ` within ${maxTopAttempts} attempts`;
            requirements.push(
              `Top Boulder ${boulderItem.index + 1}${attemptText}`
            );
          } else {
            requirements.push(`Top Boulder ${boulderItem.index + 1}`);
          }
        }

        return requirements;
      }

      function getPodiumHolders(allCompetitors) {
        const sorted = [...allCompetitors].sort(
          (a, b) => b.currentScore - a.currentScore
        );
        return [
          { position: 1, score: sorted[0]?.currentScore || 0, competitors: [] },
          { position: 2, score: sorted[1]?.currentScore || 0, competitors: [] },
          { position: 3, score: sorted[2]?.currentScore || 0, competitors: [] },
        ];
      }

      function getPodiumThreshold(allCompetitors) {
        const sorted = [...allCompetitors].sort(
          (a, b) => b.currentScore - a.currentScore
        );
        return sorted[2]?.currentScore || 0; // 3rd place score
      }

      function getPositionSuffix(position) {
        return position === 1
          ? "st"
          : position === 2
          ? "nd"
          : position === 3
          ? "rd"
          : "th";
      }

      function getPositionName(position) {
        return position === 1 ? "1st" : position === 2 ? "2nd" : "3rd";
      }

      // Initial display update
      updateDisplay();

      // Error handling for uncaught errors
      window.addEventListener("error", function (event) {
        console.error("Application error:", event.error);
        showError(
          "An unexpected error occurred. Please refresh the page if problems persist."
        );
      });
    </script>
  </body>
</html>
