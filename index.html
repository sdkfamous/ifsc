<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouldering Competition Score Tracker</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        overflow-x: auto;
        min-width: 100%;
      }
      .container {
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        min-width: fit-content;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      .table-wrapper {
        overflow-x: auto;
        margin: 0 -20px;
        padding: 0 20px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .add-competitor {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .add-competitor input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        flex: 1;
        max-width: 300px;
        min-width: 150px;
      }
      .add-competitor input:invalid {
        border-color: #f44336;
      }
      .add-competitor button {
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .add-competitor button:hover {
        background: #45a049;
      }
      .add-competitor button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .error-message {
        color: #f44336;
        font-size: 12px;
        margin-top: 5px;
        display: none;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        min-width: 800px;
      }
      th,
      td {
        padding: 8px 6px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        white-space: nowrap;
        vertical-align: top;
      }
      th {
        background-color: #f8f9fa;
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .boulder-section {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        white-space: nowrap;
        padding: 0;
      }
      .boulder-controls {
        display: flex;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
      }
      .boulder-row {
        display: flex;
        gap: 6px;
        align-items: center;
        font-size: 12px;
      }
      .boulder-row .ternary-button {
        min-width: 50px;
        font-size: 11px;
      }

      .ternary-button {
        width: 50px;
        height: 26px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 4px;
        font-size: 11px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2px;
        transition: all 0.2s ease;
      }
      .ternary-button:hover {
        background: #f0f0f0;
      }
      .ternary-button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .ternary-button.success {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }
      .ternary-button.failed {
        background: #f44336;
        color: white;
        border-color: #f44336;
      }
      .attempts-control {
        display: flex;
        align-items: center;
        gap: 3px;
      }
      .attempts-control button {
        width: 20px;
        height: 20px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 3px;
        font-size: 14px;
        line-height: 1;
        padding: 0;
        transition: background-color 0.2s ease;
      }
      .attempts-control button:hover {
        background: #f0f0f0;
      }
      .attempts-control button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .attempts-control input {
        width: 32px;
        text-align: center;
        border: 1px solid #ddd;
        border-radius: 3px;
        padding: 2px;
        font-size: 12px;
      }
      .attempts-control input:invalid {
        border-color: #f44336;
      }
      .score {
        font-weight: bold;
        font-size: 12px;
        color: #666;
        margin-top: 2px;
        text-align: left;
      }
      .total-score {
        font-weight: bold;
        font-size: 16px;
        color: #333;
      }
      .position {
        font-weight: bold;
        font-size: 18px;
      }
      .position-1 {
        color: #ffd700;
      }
      .position-2 {
        color: #c0c0c0;
      }
      .position-3 {
        color: #cd7f32;
      }
      .remove-btn {
        background: #f44336;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s ease;
      }
      .remove-btn:hover {
        background: #da190b;
      }
      .remove-btn:focus {
        outline: 2px solid #f44336;
        outline-offset: 2px;
      }
      .loading {
        opacity: 0.6;
        pointer-events: none;
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .container {
          padding: 15px;
          border-radius: 4px;
          min-width: calc(100vw - 20px);
        }
        .table-wrapper {
          margin: 0 -15px;
          padding: 0 15px;
        }
        table {
          font-size: 12px;
        }
        th,
        td {
          padding: 6px 3px;
        }
        .boulder-controls {
          gap: 4px;
        }
        .boulder-row {
          gap: 5px;
        }
        .add-competitor input {
          min-width: 120px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ§— Bouldering Competition Score Tracker</h1>

      <div class="add-competitor">
        <input
          type="text"
          id="competitorName"
          placeholder="Enter competitor name"
          maxlength="50"
          aria-label="Competitor name"
          autocomplete="off"
        />
        <button
          onclick="addCompetitor()"
          id="addButton"
          aria-label="Add competitor"
        >
          Add Competitor
        </button>
        <span
          id="competitorCount"
          style="margin-left: 10px; color: #666"
          aria-live="polite"
          >0 competitors</span
        >
      </div>
      <div
        class="error-message"
        id="errorMessage"
        role="alert"
        aria-live="polite"
      ></div>

      <div style="margin: 20px 0">
        <button
          onclick="showPodiumAnalysis()"
          style="
            padding: 10px 20px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
          "
          aria-label="Analyze podium chances"
          onmouseover="this.style.background='#1976d2'"
          onmouseout="this.style.background='#2196f3'"
        >
          ðŸ“Š Analyze Podium Chances
        </button>
      </div>

      <div
        id="podiumAnalysis"
        style="
          display: none;
          margin: 20px 0;
          padding: 20px;
          background: #f8f9fa;
          border-radius: 8px;
        "
        role="region"
        aria-labelledby="analysisTitle"
      >
        <h2 id="analysisTitle" style="margin-top: 0">Podium Analysis</h2>
        <div id="analysisContent"></div>
      </div>

      <div class="table-wrapper">
        <table id="scoreTable" role="table" aria-label="Competition scores">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Boulder 1</th>
              <th scope="col">Boulder 2</th>
              <th scope="col">Boulder 3</th>
              <th scope="col">Boulder 4</th>
              <th scope="col">Total</th>
              <th scope="col">Action</th>
            </tr>
          </thead>
          <tbody id="competitorsList"></tbody>
        </table>
      </div>
    </div>

    <script>
      let competitors = [];
      let competitorId = 0;
      let isUpdating = false;
      const MAX_COMPETITORS = 50;
      const MAX_ATTEMPTS = 50;
      const DECIMAL_PRECISION = 1;

      // Scoring constants
      const TOP_SCORE = 25; // Points awarded for completing a boulder (top)
      const ZONE_SCORE = 10; // Points awarded for reaching the zone
      const ATTEMPT_DEDUCTION = 0.1; // Points deducted per additional attempt
      const MAX_ANALYSIS_ATTEMPTS = 20; // Maximum attempts shown in analysis scenarios

      // Utility functions
      function sanitizeInput(input) {
        return input.trim().replace(/[<>'"&]/g, "");
      }

      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function validateCompetitorName(name) {
        if (!name || name.length === 0) {
          return "Please enter a competitor name";
        }
        if (name.length > 50) {
          return "Name must be 50 characters or less";
        }
        if (
          competitors.some((c) => c.name.toLowerCase() === name.toLowerCase())
        ) {
          return "A competitor with this name already exists";
        }
        return null;
      }

      function addCompetitor() {
        const nameInput = document.getElementById("competitorName");
        const name = sanitizeInput(nameInput.value);

        const validationError = validateCompetitorName(name);
        if (validationError) {
          showError(validationError);
          nameInput.focus();
          return;
        }

        if (competitors.length >= MAX_COMPETITORS) {
          showError(`Maximum ${MAX_COMPETITORS} competitors allowed`);
          return;
        }

        const competitor = {
          id: competitorId++,
          name: name,
          boulders: Array(4)
            .fill(null)
            .map(() => ({
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            })),
        };

        competitors.push(competitor);
        nameInput.value = "";
        updateDisplay();

        // Update button state
        if (competitors.length >= MAX_COMPETITORS) {
          document.getElementById("addButton").disabled = true;
        }

        // Announce to screen readers
        const announcement = `Added competitor ${name}. Total: ${competitors.length} competitors.`;
        announceToScreenReader(announcement);
      }

      function removeCompetitor(id) {
        const competitor = competitors.find((c) => c.id === id);
        if (!competitor) return;

        if (confirm(`Are you sure you want to remove ${competitor.name}?`)) {
          competitors = competitors.filter((c) => c.id !== id);
          updateDisplay();
          document.getElementById("addButton").disabled = false;

          // Announce to screen readers
          announceToScreenReader(`Removed competitor ${competitor.name}`);
        }
      }

      function updateZone(competitorId, boulderIndex) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        // Cycle through: null (not attempted) -> true (achieved) -> false (failed) -> null
        if (boulder.zone === null) {
          boulder.zone = true;
          boulder.attempted = true;
        } else if (boulder.zone === true) {
          boulder.zone = false;
          // If zone failed, top cannot be achieved
          if (boulder.top) {
            boulder.top = false;
          }
        } else {
          boulder.zone = null;
          boulder.attempted = false;
          boulder.top = false;
          boulder.zoneAttempts = 1; // Reset attempts when not attempted
          boulder.topAttempts = 1;
        }

        debouncedUpdateDisplay();
      }

      function updateTop(competitorId, boulderIndex) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        // Toggle between false and true (only two states)
        boulder.top = !boulder.top;
        boulder.attempted = true;

        // If checking top, zone must be achieved (logical consistency)
        if (boulder.top) {
          boulder.zone = true;
          // Ensure topAttempts >= zoneAttempts
          if (boulder.topAttempts < boulder.zoneAttempts) {
            boulder.topAttempts = boulder.zoneAttempts;
          }
        }

        debouncedUpdateDisplay();
      }

      function updateZoneAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Zone attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        const boulder = competitor.boulders[boulderIndex];
        boulder.zoneAttempts = attempts;

        // Zone attempts automatically set the minimum for top attempts
        // (since all attempts to reach zone are also attempts toward the top)
        if (boulder.topAttempts < attempts) {
          boulder.topAttempts = attempts;
        }

        debouncedUpdateDisplay();
      }

      function changeZoneAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        const newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.zoneAttempts + delta)
        );
        boulder.zoneAttempts = newAttempts;

        // Zone attempts automatically set the minimum for top attempts
        // (since all attempts to reach zone are also attempts toward the top)
        if (boulder.topAttempts < newAttempts) {
          boulder.topAttempts = newAttempts;
        }

        debouncedUpdateDisplay();
      }

      function updateTopAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Top attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        const boulder = competitor.boulders[boulderIndex];

        // If zone is achieved, ensure topAttempts >= zoneAttempts
        if (boulder.zone === true && attempts < boulder.zoneAttempts) {
          showError(
            `Top attempts (${attempts}) cannot be less than zone attempts (${boulder.zoneAttempts})`
          );
          return;
        }

        boulder.topAttempts = attempts;
        debouncedUpdateDisplay();
      }

      function changeTopAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        let newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.topAttempts + delta)
        );

        // If zone is achieved, ensure topAttempts >= zoneAttempts
        if (boulder.zone === true) {
          newAttempts = Math.max(newAttempts, boulder.zoneAttempts);
        }

        boulder.topAttempts = newAttempts;
        debouncedUpdateDisplay();
      }

      function calculateBoulderScore(boulder) {
        // Migrate old format if needed
        if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
          boulder.zoneAttempts = boulder.attempts;
          boulder.topAttempts = boulder.attempts;
          delete boulder.attempts;
        }

        if (!boulder.attempted || boulder.zone === null) return 0;
        if (boulder.zone === false && !boulder.top) return 0; // Failed

        let score = 0;
        let attemptsToDeduct = 0;

        if (boulder.top) {
          score = TOP_SCORE;
          attemptsToDeduct = boulder.topAttempts;
        } else if (boulder.zone === true) {
          score = ZONE_SCORE;
          attemptsToDeduct = boulder.zoneAttempts;
        }

        // Deduct ATTEMPT_DEDUCTION for each attempt after the first
        const deduction = (attemptsToDeduct - 1) * ATTEMPT_DEDUCTION;
        return Math.max(0, Math.round((score - deduction) * 10) / 10); // Round to 1 decimal place
      }

      function calculateTotalScore(competitor) {
        const total = competitor.boulders.reduce((sum, boulder) => {
          return sum + calculateBoulderScore(boulder);
        }, 0);
        return Math.round(total * 10) / 10; // Round to 1 decimal place
      }

      function updateDisplay() {
        if (isUpdating) return;
        isUpdating = true;

        const tbody = document.getElementById("competitorsList");
        const competitorCount = document.getElementById("competitorCount");
        const container = document.querySelector(".container");

        // Show loading state
        container.classList.add("loading");

        // Update competitor count
        competitorCount.textContent = `${competitors.length} competitor${
          competitors.length !== 1 ? "s" : ""
        }`;

        // Calculate scores but keep original order
        const competitorsWithScores = competitors.map((c) => ({
          ...c,
          totalScore: calculateTotalScore(c),
        }));

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();

        // Add rows for each competitor in original order
        competitorsWithScores.forEach((competitor, index) => {
          const row = document.createElement("tr");
          row.setAttribute("data-competitor-id", competitor.id);

          // Show row number instead of position
          const posCell = document.createElement("td");
          posCell.textContent = index + 1;
          row.appendChild(posCell);

          // Name
          const nameCell = document.createElement("td");
          nameCell.textContent = competitor.name;
          nameCell.setAttribute("data-label", "Name");
          row.appendChild(nameCell);

          // Boulders
          for (let i = 0; i < 4; i++) {
            const boulder = competitor.boulders[i];
            const boulderCell = document.createElement("td");
            boulderCell.setAttribute("data-label", `Boulder ${i + 1}`);

            const boulderSection = document.createElement("div");
            boulderSection.className = "boulder-section";

            const controls = document.createElement("div");
            controls.className = "boulder-controls";

            // Migrate old format if needed
            if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
              boulder.zoneAttempts = boulder.attempts;
              boulder.topAttempts = boulder.attempts;
              delete boulder.attempts;
            }

            // Zone row
            const zoneRow = document.createElement("div");
            zoneRow.className = "boulder-row";

            // Zone ternary button
            const zoneButton = document.createElement("button");
            zoneButton.className = "ternary-button";
            zoneButton.setAttribute(
              "aria-label",
              `Toggle zone status for boulder ${i + 1}`
            );
            zoneButton.setAttribute("tabindex", "0");

            if (boulder.zone === true) {
              zoneButton.className += " success";
              zoneButton.setAttribute("aria-pressed", "true");
            } else if (boulder.zone === false) {
              zoneButton.className += " failed";
              zoneButton.setAttribute("aria-pressed", "false");
            } else {
              zoneButton.setAttribute("aria-pressed", "mixed");
            }

            zoneButton.textContent = "Zone";
            zoneButton.onclick = () => updateZone(competitor.id, i);
            zoneButton.onkeydown = (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                updateZone(competitor.id, i);
              }
            };

            // Zone attempts control
            const zoneAttemptsControl = document.createElement("div");
            zoneAttemptsControl.className = "attempts-control";
            zoneAttemptsControl.setAttribute("role", "group");
            zoneAttemptsControl.setAttribute(
              "aria-label",
              `Attempts to achieve zone for boulder ${i + 1}`
            );

            const zoneMinusBtn = document.createElement("button");
            zoneMinusBtn.textContent = "-";
            zoneMinusBtn.setAttribute(
              "aria-label",
              "Decrease attempts to achieve zone"
            );
            zoneMinusBtn.onclick = () =>
              changeZoneAttempts(competitor.id, i, -1);

            const zoneAttemptsInput = document.createElement("input");
            zoneAttemptsInput.type = "number";
            zoneAttemptsInput.min = "1";
            zoneAttemptsInput.max = MAX_ATTEMPTS.toString();
            zoneAttemptsInput.value = boulder.zoneAttempts;
            zoneAttemptsInput.setAttribute(
              "aria-label",
              `Number of attempts to achieve zone for boulder ${i + 1}`
            );
            zoneAttemptsInput.onchange = (e) =>
              updateZoneAttempts(competitor.id, i, e.target.value);

            const zonePlusBtn = document.createElement("button");
            zonePlusBtn.textContent = "+";
            zonePlusBtn.setAttribute(
              "aria-label",
              "Increase attempts to achieve zone"
            );
            zonePlusBtn.onclick = () => changeZoneAttempts(competitor.id, i, 1);

            zoneAttemptsControl.appendChild(zoneMinusBtn);
            zoneAttemptsControl.appendChild(zoneAttemptsInput);
            zoneAttemptsControl.appendChild(zonePlusBtn);

            zoneRow.appendChild(zoneButton);
            zoneRow.appendChild(zoneAttemptsControl);

            // Top row
            const topRow = document.createElement("div");
            topRow.className = "boulder-row";

            // Top toggle button
            const topButton = document.createElement("button");
            topButton.className = "ternary-button";
            topButton.setAttribute(
              "aria-label",
              `Toggle top status for boulder ${i + 1}`
            );
            topButton.setAttribute("tabindex", "0");

            if (boulder.top) {
              topButton.className += " success";
              topButton.setAttribute("aria-pressed", "true");
            } else {
              topButton.setAttribute("aria-pressed", "false");
            }

            topButton.textContent = "Top";
            topButton.onclick = () => updateTop(competitor.id, i);
            topButton.onkeydown = (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                updateTop(competitor.id, i);
              }
            };

            // Top attempts control
            const topAttemptsControl = document.createElement("div");
            topAttemptsControl.className = "attempts-control";
            topAttemptsControl.setAttribute("role", "group");
            topAttemptsControl.setAttribute(
              "aria-label",
              `Total attempts to achieve top for boulder ${i + 1}`
            );

            const topMinusBtn = document.createElement("button");
            topMinusBtn.textContent = "-";
            topMinusBtn.setAttribute(
              "aria-label",
              "Decrease total attempts to achieve top"
            );
            topMinusBtn.onclick = () => changeTopAttempts(competitor.id, i, -1);

            const topAttemptsInput = document.createElement("input");
            topAttemptsInput.type = "number";
            topAttemptsInput.min = "1";
            topAttemptsInput.max = MAX_ATTEMPTS.toString();
            topAttemptsInput.value = boulder.topAttempts;
            topAttemptsInput.setAttribute(
              "aria-label",
              `Total number of attempts to achieve top for boulder ${i + 1}`
            );
            topAttemptsInput.onchange = (e) =>
              updateTopAttempts(competitor.id, i, e.target.value);

            const topPlusBtn = document.createElement("button");
            topPlusBtn.textContent = "+";
            topPlusBtn.setAttribute(
              "aria-label",
              "Increase total attempts to achieve top"
            );
            topPlusBtn.onclick = () => changeTopAttempts(competitor.id, i, 1);

            topAttemptsControl.appendChild(topMinusBtn);
            topAttemptsControl.appendChild(topAttemptsInput);
            topAttemptsControl.appendChild(topPlusBtn);

            topRow.appendChild(topButton);
            topRow.appendChild(topAttemptsControl);

            controls.appendChild(zoneRow);
            controls.appendChild(topRow);
            boulderSection.appendChild(controls);

            // Score display
            const score = calculateBoulderScore(boulder);
            const scoreDiv = document.createElement("div");
            scoreDiv.className = "score";
            scoreDiv.textContent = `Score: ${score.toFixed(1)}`;
            scoreDiv.setAttribute(
              "aria-label",
              `Boulder ${i + 1} score: ${score.toFixed(1)} points`
            );
            boulderSection.appendChild(scoreDiv);

            boulderCell.appendChild(boulderSection);
            row.appendChild(boulderCell);
          }

          // Total score
          const totalCell = document.createElement("td");
          totalCell.setAttribute("data-label", "Total");
          totalCell.innerHTML = `<span class="total-score">${competitor.totalScore.toFixed(
            1
          )}</span>`;
          totalCell.setAttribute(
            "aria-label",
            `Total score: ${competitor.totalScore.toFixed(1)} points`
          );
          row.appendChild(totalCell);

          // Remove button
          const actionCell = document.createElement("td");
          actionCell.setAttribute("data-label", "Action");
          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-btn";
          removeBtn.textContent = "Remove";
          removeBtn.setAttribute(
            "aria-label",
            `Remove competitor ${competitor.name}`
          );
          removeBtn.onclick = () => removeCompetitor(competitor.id);
          actionCell.appendChild(removeBtn);
          row.appendChild(actionCell);

          fragment.appendChild(row);
        });

        // Clear and update tbody
        tbody.innerHTML = "";
        tbody.appendChild(fragment);

        // Remove loading state
        container.classList.remove("loading");
        isUpdating = false;
      }

      // Debounced version of updateDisplay for better performance
      const debouncedUpdateDisplay = debounce(updateDisplay, 100);

      function announceToScreenReader(message) {
        const announcement = document.createElement("div");
        announcement.setAttribute("aria-live", "polite");
        announcement.setAttribute("aria-atomic", "true");
        announcement.style.position = "absolute";
        announcement.style.left = "-9999px";
        announcement.textContent = message;
        document.body.appendChild(announcement);
        setTimeout(() => document.body.removeChild(announcement), 1000);
      }

      // Allow Enter key to add competitor
      document
        .getElementById("competitorName")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            addCompetitor();
          }
        });

      function showPodiumAnalysis() {
        const analysisDiv = document.getElementById("podiumAnalysis");
        const content = document.getElementById("analysisContent");

        if (competitors.length === 0) {
          showError("Please add competitors first");
          return;
        }

        // Toggle display
        if (analysisDiv.style.display === "none") {
          analysisDiv.style.display = "block";
          content.innerHTML = generatePodiumAnalysis();
        } else {
          analysisDiv.style.display = "none";
        }
      }

      function generatePodiumAnalysis() {
        try {
          // Calculate current scores and get current standings
          const competitorAnalysis = competitors.map((c) => {
            const currentScore = calculateTotalScore(c);
            const unattemptedBoulders = c.boulders.filter((b) => !b.attempted);
            const remainingBoulders = unattemptedBoulders.length;
            const maxPossibleScore =
              currentScore + remainingBoulders * TOP_SCORE;

            return {
              ...c,
              currentScore,
              remainingBoulders,
              unattemptedBoulders,
              maxPossibleScore,
            };
          });

          // Sort by current score to find current standings
          const currentStandings = [...competitorAnalysis].sort(
            (a, b) => b.currentScore - a.currentScore
          );

          // Add current position to each competitor (handling ties correctly)
          let currentPosition = 1;
          let previousScore = null;
          let tiedCount = 0;

          currentStandings.forEach((comp, index) => {
            if (
              previousScore !== null &&
              Math.abs(comp.currentScore - previousScore) > 0.01
            ) {
              // Score changed, advance position by number of tied competitors
              currentPosition += tiedCount;
              tiedCount = 1;
            } else {
              // Same score or first competitor
              tiedCount++;
            }
            comp.currentPosition = currentPosition;
            previousScore = comp.currentScore;
          });

          // Update the original analysis array with correct positions
          competitorAnalysis.forEach((comp) => {
            const standingComp = currentStandings.find((c) => c.id === comp.id);
            comp.currentPosition = standingComp.currentPosition;
          });

          let html = "";

          // Sort by current position for display
          const sortedByPosition = [...competitorAnalysis].sort(
            (a, b) => a.currentPosition - b.currentPosition
          );

          sortedByPosition.forEach((competitor) => {
            const scenarios = analyzePodiumScenarios(
              competitor,
              competitorAnalysis,
              currentStandings
            );

            // Check if this competitor is tied with others
            const competitorsAtSameScore = currentStandings.filter(
              (c) => Math.abs(c.currentScore - competitor.currentScore) < 0.01
            ).length;

            const positionSuffix =
              competitor.currentPosition === 1
                ? "st"
                : competitor.currentPosition === 2
                ? "nd"
                : competitor.currentPosition === 3
                ? "rd"
                : "th";

            let positionText;
            if (competitorsAtSameScore > 1) {
              positionText = `tied for ${competitor.currentPosition}${positionSuffix} place`;
            } else {
              positionText = `${competitor.currentPosition}${positionSuffix} place`;
            }

            html += `<div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 4px; border: 1px solid #ddd;">`;
            html += `<h3 style="margin-top: 0; color: #333;">${
              competitor.name
            } - Currently ${positionText} (${competitor.currentScore.toFixed(
              1
            )} points)</h3>`;

            if (competitor.remainingBoulders === 0) {
              html += `<p style="color: #666;">All boulders attempted - final score: ${competitor.currentScore.toFixed(
                1
              )} points</p>`;
            } else if (scenarios.length === 0) {
              html += `<p style="color: #666;">Cannot reach podium - maximum possible score: ${competitor.maxPossibleScore.toFixed(
                1
              )} points</p>`;
            } else {
              html += `<ul style="margin: 0; padding-left: 20px;">`;
              scenarios.forEach((scenario) => {
                html += `<li style="margin-bottom: 8px; color: #333;">${scenario}</li>`;
              });
              html += `</ul>`;
            }

            html += `</div>`;
          });

          return html;
        } catch (error) {
          console.error("Error generating podium analysis:", error);
          return `<p style="color: #f44336;">Error generating analysis. Please try again.</p>`;
        }
      }

      function analyzePodiumScenarios(
        competitor,
        allCompetitors,
        currentStandings
      ) {
        const scenarios = [];
        const unattemptedBoulders = competitor.boulders
          .map((b, idx) => ({ boulder: b, index: idx }))
          .filter((item) => !item.boulder.attempted);

        if (unattemptedBoulders.length === 0) {
          return scenarios;
        }

        // Calculate potential scenarios based on remaining boulders
        const potentialScenarios = [];

        // Check single boulder completions
        unattemptedBoulders.forEach((item, idx) => {
          // Check each position that would be an improvement
          for (
            let targetPosition = 1;
            targetPosition < competitor.currentPosition;
            targetPosition++
          ) {
            // Get the score we need to beat for this position
            let targetScore = 0;
            if (targetPosition === 1) {
              targetScore = currentStandings[0]?.currentScore || 0;
            } else if (targetPosition === 2) {
              targetScore = currentStandings[1]?.currentScore || 0;
            } else if (targetPosition === 3) {
              targetScore = currentStandings[2]?.currentScore || 0;
            }

            // Top completion scenario
            const maxTopAttempts = Math.floor(
              (competitor.currentScore + TOP_SCORE - targetScore - 0.01) /
                ATTEMPT_DEDUCTION +
                1
            );

            if (maxTopAttempts >= 1 && maxTopAttempts <= 50) {
              const topFinalScore =
                competitor.currentScore +
                TOP_SCORE -
                (maxTopAttempts - 1) * ATTEMPT_DEDUCTION;
              const topPosition = calculatePosition(
                topFinalScore,
                currentStandings,
                competitor.id
              );

              if (topPosition === targetPosition) {
                let attemptText;
                if (maxTopAttempts >= 50) {
                  attemptText = "any number of attempts";
                } else if (maxTopAttempts === 1) {
                  attemptText = "1 attempt";
                } else {
                  attemptText = `up to ${maxTopAttempts} attempts`;
                }

                potentialScenarios.push({
                  action: `Complete Boulder ${
                    item.index + 1
                  } top in ${attemptText}`,
                  position: targetPosition,
                  score: topFinalScore,
                  attempts: maxTopAttempts,
                  boulderIndex: item.index,
                });
              }
            }
          }

          // Zone only scenario - find what positions are achievable and max attempts allowed
          const bestZoneScore = competitor.currentScore + ZONE_SCORE;

          // Check each position that would be an improvement
          for (
            let targetPosition = 1;
            targetPosition < competitor.currentPosition;
            targetPosition++
          ) {
            // Get the score we need to beat for this position
            let targetScore = 0;
            if (targetPosition === 1) {
              targetScore = currentStandings[0]?.currentScore || 0;
            } else if (targetPosition === 2) {
              targetScore = currentStandings[1]?.currentScore || 0;
            } else if (targetPosition === 3) {
              targetScore = currentStandings[2]?.currentScore || 0;
            }

            // Only consider zone if it can beat the target score at all
            if (bestZoneScore > targetScore) {
              // Calculate max attempts allowed while still beating this score
              // We need to beat (not tie), so subtract a small amount to ensure strict inequality
              const maxAttempts = Math.floor(
                (competitor.currentScore + ZONE_SCORE - targetScore - 0.01) /
                  ATTEMPT_DEDUCTION +
                  1
              );

              if (maxAttempts >= 1 && maxAttempts <= 50) {
                const actualFinalScore =
                  competitor.currentScore +
                  ZONE_SCORE -
                  (maxAttempts - 1) * ATTEMPT_DEDUCTION;
                const actualPosition = calculatePosition(
                  actualFinalScore,
                  currentStandings,
                  competitor.id
                );

                // Only show zone scenario if it gives a different position than top
                const topFinalScore =
                  competitor.currentScore +
                  TOP_SCORE -
                  (maxAttempts - 1) * ATTEMPT_DEDUCTION;
                const topPosition = calculatePosition(
                  topFinalScore,
                  currentStandings,
                  competitor.id
                );

                if (
                  actualPosition === targetPosition &&
                  actualPosition !== topPosition
                ) {
                  let attemptText;
                  if (maxAttempts >= 50) {
                    attemptText = "any number of attempts";
                  } else if (maxAttempts === 1) {
                    attemptText = "1 attempt";
                  } else {
                    attemptText = `up to ${maxAttempts} attempts`;
                  }

                  potentialScenarios.push({
                    action: `Get Boulder ${
                      item.index + 1
                    } zone in ${attemptText}`,
                    position: targetPosition,
                    score: actualFinalScore,
                    attempts: maxAttempts,
                    boulderIndex: item.index,
                  });
                  // Don't break - continue checking other positions for this boulder
                }
              }
            }
          }
        });

        // Check multi-boulder scenarios only if needed
        if (
          potentialScenarios.length === 0 &&
          unattemptedBoulders.length >= 2
        ) {
          for (
            let topsNeeded = 2;
            topsNeeded <= Math.min(3, unattemptedBoulders.length);
            topsNeeded++
          ) {
            const multiTopScore =
              competitor.currentScore + topsNeeded * TOP_SCORE;
            const multiTopPosition = calculatePosition(
              multiTopScore,
              currentStandings,
              competitor.id
            );
            // Only show if this IMPROVES their current position
            if (
              multiTopPosition <= 3 &&
              multiTopPosition < competitor.currentPosition
            ) {
              const boulderList = unattemptedBoulders
                .slice(0, topsNeeded)
                .map((b) => b.index + 1)
                .join(", ");
              potentialScenarios.push({
                action: `Complete ${topsNeeded} tops (e.g., Boulders ${boulderList})`,
                position: multiTopPosition,
                score: multiTopScore,
              });
              break; // Only show the minimum needed for improvement
            }
          }
        }

        // Sort scenarios by position (best first) and add to results
        potentialScenarios
          .sort((a, b) => a.position - b.position)
          .slice(0, 4) // Show max 4 scenarios to avoid clutter
          .forEach((scenario) => {
            const positionName =
              scenario.position === 1
                ? "1st"
                : scenario.position === 2
                ? "2nd"
                : "3rd";
            scenarios.push(`For ${positionName}: ${scenario.action}`);
          });

        // If no improvement scenarios, show status
        if (potentialScenarios.length === 0) {
          if (competitor.currentPosition === 1) {
            scenarios.push(
              "Currently holding 1st place - no improvement possible"
            );
          } else if (competitor.currentPosition <= 3) {
            const positionSuffix =
              competitor.currentPosition === 2 ? "nd" : "rd";
            scenarios.push(
              `Currently holding ${competitor.currentPosition}${positionSuffix} place - no podium improvement possible`
            );
          }
        }

        return scenarios;
      }

      // Helper function to calculate what position a score would achieve
      function calculatePosition(score, currentStandings, competitorId) {
        const otherStandings = currentStandings.filter(
          (c) => c.id !== competitorId
        );

        // Sort by score descending to get proper ranking
        const sortedOthers = otherStandings.sort(
          (a, b) => b.currentScore - a.currentScore
        );

        // Find position accounting for ties
        let position = 1;
        let previousScore = null;
        let tiedCount = 0;

        for (let i = 0; i < sortedOthers.length; i++) {
          const competitor = sortedOthers[i];

          if (
            previousScore !== null &&
            Math.abs(competitor.currentScore - previousScore) > 0.01
          ) {
            // Score changed, advance position
            position += tiedCount;
            tiedCount = 1;
          } else {
            // Same score or first competitor
            tiedCount++;
          }

          // If this competitor's score is higher than our target score, we'll be behind them
          if (competitor.currentScore > score) {
            position = position + tiedCount;
            tiedCount = 0;
          } else {
            // Our score would beat or tie with this competitor
            break;
          }

          previousScore = competitor.currentScore;
        }

        return position;
      }

      // Initial display update
      updateDisplay();

      // Error handling for uncaught errors
      window.addEventListener("error", function (event) {
        console.error("Application error:", event.error);
        showError(
          "An unexpected error occurred. Please refresh the page if problems persist."
        );
      });
    </script>
  </body>
</html>
