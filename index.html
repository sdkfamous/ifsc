<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouldering Competition Score Tracker</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        overflow-x: auto;
        min-width: 100%;
      }
      .container {
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        min-width: fit-content;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      .table-wrapper {
        overflow-x: auto;
        margin: 0 -20px;
        padding: 0 20px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .add-competitor {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .add-competitor input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        flex: 1;
        max-width: 300px;
        min-width: 150px;
      }
      .add-competitor input:invalid {
        border-color: #f44336;
      }
      .add-competitor button {
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .add-competitor button:hover {
        background: #45a049;
      }
      .add-competitor button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .error-message {
        color: #f44336;
        font-size: 12px;
        margin-top: 5px;
        display: none;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        min-width: 800px;
      }
      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        white-space: nowrap;
      }
      th {
        background-color: #f8f9fa;
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .boulder-section {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        white-space: nowrap;
      }
      .boulder-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }
      .boulder-row {
        display: flex;
        gap: 10px;
        align-items: center;
        font-size: 12px;
      }
      .boulder-row .ternary-button,
      .boulder-row .checkbox-group {
        min-width: 60px;
      }
      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .checkbox-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }
      .checkbox-group label {
        cursor: pointer;
        font-size: 14px;
      }
      .ternary-button {
        width: 60px;
        height: 28px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 4px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2px;
        transition: all 0.2s ease;
      }
      .ternary-button:hover {
        background: #f0f0f0;
      }
      .ternary-button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .ternary-button.success {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }
      .ternary-button.failed {
        background: #f44336;
        color: white;
        border-color: #f44336;
      }
      .attempts-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .attempts-control button {
        width: 24px;
        height: 24px;
        border: 1px solid #ddd;
        background: white;
        cursor: pointer;
        border-radius: 4px;
        font-size: 16px;
        line-height: 1;
        padding: 0;
        transition: background-color 0.2s ease;
      }
      .attempts-control button:hover {
        background: #f0f0f0;
      }
      .attempts-control button:focus {
        outline: 2px solid #4caf50;
        outline-offset: 2px;
      }
      .attempts-control input {
        width: 40px;
        text-align: center;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 4px;
      }
      .attempts-control input:invalid {
        border-color: #f44336;
      }
      .score {
        font-weight: bold;
        font-size: 14px;
        color: #666;
      }
      .total-score {
        font-weight: bold;
        font-size: 16px;
        color: #333;
      }
      .position {
        font-weight: bold;
        font-size: 18px;
      }
      .position-1 {
        color: #ffd700;
      }
      .position-2 {
        color: #c0c0c0;
      }
      .position-3 {
        color: #cd7f32;
      }
      .remove-btn {
        background: #f44336;
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s ease;
      }
      .remove-btn:hover {
        background: #da190b;
      }
      .remove-btn:focus {
        outline: 2px solid #f44336;
        outline-offset: 2px;
      }
      .loading {
        opacity: 0.6;
        pointer-events: none;
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .container {
          padding: 15px;
          border-radius: 4px;
          min-width: calc(100vw - 20px);
        }
        .table-wrapper {
          margin: 0 -15px;
          padding: 0 15px;
        }
        table {
          font-size: 12px;
        }
        th,
        td {
          padding: 8px 4px;
        }
        .boulder-controls {
          gap: 4px;
        }
        .boulder-row {
          gap: 5px;
        }
        .add-competitor input {
          min-width: 120px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ§— Bouldering Competition Score Tracker</h1>

      <div class="add-competitor">
        <input
          type="text"
          id="competitorName"
          placeholder="Enter competitor name"
          maxlength="50"
          aria-label="Competitor name"
          autocomplete="off"
        />
        <button
          onclick="addCompetitor()"
          id="addButton"
          aria-label="Add competitor"
        >
          Add Competitor
        </button>
        <span
          id="competitorCount"
          style="margin-left: 10px; color: #666"
          aria-live="polite"
          >0 competitors</span
        >
      </div>
      <div
        class="error-message"
        id="errorMessage"
        role="alert"
        aria-live="polite"
      ></div>

      <div style="margin: 20px 0">
        <button
          onclick="showPodiumAnalysis()"
          style="
            padding: 10px 20px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
          "
          aria-label="Analyze podium chances"
          onmouseover="this.style.background='#1976d2'"
          onmouseout="this.style.background='#2196f3'"
        >
          ðŸ“Š Analyze Podium Chances
        </button>
      </div>

      <div
        id="podiumAnalysis"
        style="
          display: none;
          margin: 20px 0;
          padding: 20px;
          background: #f8f9fa;
          border-radius: 8px;
        "
        role="region"
        aria-labelledby="analysisTitle"
      >
        <h2 id="analysisTitle" style="margin-top: 0">Podium Analysis</h2>
        <div id="analysisContent"></div>
      </div>

      <div class="table-wrapper">
        <table id="scoreTable" role="table" aria-label="Competition scores">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Boulder 1</th>
              <th scope="col">Boulder 2</th>
              <th scope="col">Boulder 3</th>
              <th scope="col">Boulder 4</th>
              <th scope="col">Total</th>
              <th scope="col">Action</th>
            </tr>
          </thead>
          <tbody id="competitorsList"></tbody>
        </table>
      </div>
    </div>

    <script>
      let competitors = [];
      let competitorId = 0;
      let isUpdating = false;
      const MAX_COMPETITORS = 50;
      const MAX_ATTEMPTS = 50;
      const DECIMAL_PRECISION = 1;

      // Scoring constants
      const TOP_SCORE = 25; // Points awarded for completing a boulder (top)
      const ZONE_SCORE = 10; // Points awarded for reaching the zone
      const ATTEMPT_DEDUCTION = 0.1; // Points deducted per additional attempt
      const MAX_ANALYSIS_ATTEMPTS = 20; // Maximum attempts shown in analysis scenarios

      // Utility functions
      function sanitizeInput(input) {
        return input.trim().replace(/[<>'"&]/g, "");
      }

      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function validateCompetitorName(name) {
        if (!name || name.length === 0) {
          return "Please enter a competitor name";
        }
        if (name.length > 50) {
          return "Name must be 50 characters or less";
        }
        if (
          competitors.some((c) => c.name.toLowerCase() === name.toLowerCase())
        ) {
          return "A competitor with this name already exists";
        }
        return null;
      }

      function addCompetitor() {
        const nameInput = document.getElementById("competitorName");
        const name = sanitizeInput(nameInput.value);

        const validationError = validateCompetitorName(name);
        if (validationError) {
          showError(validationError);
          nameInput.focus();
          return;
        }

        if (competitors.length >= MAX_COMPETITORS) {
          showError(`Maximum ${MAX_COMPETITORS} competitors allowed`);
          return;
        }

        const competitor = {
          id: competitorId++,
          name: name,
          boulders: Array(4)
            .fill(null)
            .map(() => ({
              zone: null,
              top: false,
              zoneAttempts: 1,
              topAttempts: 1,
              attempted: false,
            })),
        };

        competitors.push(competitor);
        nameInput.value = "";
        updateDisplay();

        // Update button state
        if (competitors.length >= MAX_COMPETITORS) {
          document.getElementById("addButton").disabled = true;
        }

        // Announce to screen readers
        const announcement = `Added competitor ${name}. Total: ${competitors.length} competitors.`;
        announceToScreenReader(announcement);
      }

      function removeCompetitor(id) {
        const competitor = competitors.find((c) => c.id === id);
        if (!competitor) return;

        if (confirm(`Are you sure you want to remove ${competitor.name}?`)) {
          competitors = competitors.filter((c) => c.id !== id);
          updateDisplay();
          document.getElementById("addButton").disabled = false;

          // Announce to screen readers
          announceToScreenReader(`Removed competitor ${competitor.name}`);
        }
      }

      function updateZone(competitorId, boulderIndex) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        // Cycle through: null (not attempted) -> true (achieved) -> false (failed) -> null
        if (boulder.zone === null) {
          boulder.zone = true;
          boulder.attempted = true;
        } else if (boulder.zone === true) {
          boulder.zone = false;
          // If zone failed, top cannot be achieved
          if (boulder.top) {
            boulder.top = false;
          }
        } else {
          boulder.zone = null;
          boulder.attempted = false;
          boulder.top = false;
          boulder.zoneAttempts = 1; // Reset attempts when not attempted
          boulder.topAttempts = 1;
        }

        debouncedUpdateDisplay();
      }

      function updateCheckbox(competitorId, boulderIndex, type, checked) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];

        if (type === "top") {
          boulder.top = checked;
          boulder.attempted = true;
          // If checking top, zone must be achieved (logical consistency)
          if (checked) {
            boulder.zone = true;
          }
        }

        debouncedUpdateDisplay();
      }

      function updateZoneAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Zone attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        competitor.boulders[boulderIndex].zoneAttempts = attempts;
        debouncedUpdateDisplay();
      }

      function changeZoneAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        const newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.zoneAttempts + delta)
        );
        boulder.zoneAttempts = newAttempts;
        debouncedUpdateDisplay();
      }

      function updateTopAttempts(competitorId, boulderIndex, value) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const attempts = parseInt(value) || 1;
        if (attempts < 1 || attempts > MAX_ATTEMPTS) {
          showError(`Top attempts must be between 1 and ${MAX_ATTEMPTS}`);
          return;
        }

        competitor.boulders[boulderIndex].topAttempts = attempts;
        debouncedUpdateDisplay();
      }

      function changeTopAttempts(competitorId, boulderIndex, delta) {
        const competitor = competitors.find((c) => c.id === competitorId);
        if (!competitor) return;

        const boulder = competitor.boulders[boulderIndex];
        const newAttempts = Math.max(
          1,
          Math.min(MAX_ATTEMPTS, boulder.topAttempts + delta)
        );
        boulder.topAttempts = newAttempts;
        debouncedUpdateDisplay();
      }

      function calculateBoulderScore(boulder) {
        // Migrate old format if needed
        if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
          boulder.zoneAttempts = boulder.attempts;
          boulder.topAttempts = boulder.attempts;
          delete boulder.attempts;
        }

        if (!boulder.attempted || boulder.zone === null) return 0;
        if (boulder.zone === false && !boulder.top) return 0; // Failed

        let score = 0;
        let attemptsToDeduct = 0;

        if (boulder.top) {
          score = TOP_SCORE;
          attemptsToDeduct = boulder.topAttempts;
        } else if (boulder.zone === true) {
          score = ZONE_SCORE;
          attemptsToDeduct = boulder.zoneAttempts;
        }

        // Deduct ATTEMPT_DEDUCTION for each attempt after the first
        const deduction = (attemptsToDeduct - 1) * ATTEMPT_DEDUCTION;
        return Math.max(0, Math.round((score - deduction) * 10) / 10); // Round to 1 decimal place
      }

      function calculateTotalScore(competitor) {
        const total = competitor.boulders.reduce((sum, boulder) => {
          return sum + calculateBoulderScore(boulder);
        }, 0);
        return Math.round(total * 10) / 10; // Round to 1 decimal place
      }

      function updateDisplay() {
        if (isUpdating) return;
        isUpdating = true;

        const tbody = document.getElementById("competitorsList");
        const competitorCount = document.getElementById("competitorCount");
        const container = document.querySelector(".container");

        // Show loading state
        container.classList.add("loading");

        // Update competitor count
        competitorCount.textContent = `${competitors.length} competitor${
          competitors.length !== 1 ? "s" : ""
        }`;

        // Calculate scores but keep original order
        const competitorsWithScores = competitors.map((c) => ({
          ...c,
          totalScore: calculateTotalScore(c),
        }));

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();

        // Add rows for each competitor in original order
        competitorsWithScores.forEach((competitor, index) => {
          const row = document.createElement("tr");
          row.setAttribute("data-competitor-id", competitor.id);

          // Show row number instead of position
          const posCell = document.createElement("td");
          posCell.textContent = index + 1;
          row.appendChild(posCell);

          // Name
          const nameCell = document.createElement("td");
          nameCell.textContent = competitor.name;
          nameCell.setAttribute("data-label", "Name");
          row.appendChild(nameCell);

          // Boulders
          for (let i = 0; i < 4; i++) {
            const boulder = competitor.boulders[i];
            const boulderCell = document.createElement("td");
            boulderCell.setAttribute("data-label", `Boulder ${i + 1}`);

            const boulderSection = document.createElement("div");
            boulderSection.className = "boulder-section";

            const controls = document.createElement("div");
            controls.className = "boulder-controls";

            // Migrate old format if needed
            if ("attempts" in boulder && !("zoneAttempts" in boulder)) {
              boulder.zoneAttempts = boulder.attempts;
              boulder.topAttempts = boulder.attempts;
              delete boulder.attempts;
            }

            // Zone row
            const zoneRow = document.createElement("div");
            zoneRow.className = "boulder-row";

            // Zone ternary button
            const zoneButton = document.createElement("button");
            zoneButton.className = "ternary-button";
            zoneButton.setAttribute(
              "aria-label",
              `Toggle zone status for boulder ${i + 1}`
            );
            zoneButton.setAttribute("tabindex", "0");

            if (boulder.zone === true) {
              zoneButton.className += " success";
              zoneButton.setAttribute("aria-pressed", "true");
            } else if (boulder.zone === false) {
              zoneButton.className += " failed";
              zoneButton.setAttribute("aria-pressed", "false");
            } else {
              zoneButton.setAttribute("aria-pressed", "mixed");
            }

            zoneButton.textContent = "Zone";
            zoneButton.onclick = () => updateZone(competitor.id, i);
            zoneButton.onkeydown = (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                updateZone(competitor.id, i);
              }
            };

            // Zone attempts control
            const zoneAttemptsControl = document.createElement("div");
            zoneAttemptsControl.className = "attempts-control";
            zoneAttemptsControl.setAttribute("role", "group");
            zoneAttemptsControl.setAttribute(
              "aria-label",
              `Zone attempts for boulder ${i + 1}`
            );

            const zoneMinusBtn = document.createElement("button");
            zoneMinusBtn.textContent = "-";
            zoneMinusBtn.setAttribute("aria-label", "Decrease zone attempts");
            zoneMinusBtn.onclick = () =>
              changeZoneAttempts(competitor.id, i, -1);

            const zoneAttemptsInput = document.createElement("input");
            zoneAttemptsInput.type = "number";
            zoneAttemptsInput.min = "1";
            zoneAttemptsInput.max = MAX_ATTEMPTS.toString();
            zoneAttemptsInput.value = boulder.zoneAttempts;
            zoneAttemptsInput.setAttribute(
              "aria-label",
              `Number of zone attempts for boulder ${i + 1}`
            );
            zoneAttemptsInput.onchange = (e) =>
              updateZoneAttempts(competitor.id, i, e.target.value);

            const zonePlusBtn = document.createElement("button");
            zonePlusBtn.textContent = "+";
            zonePlusBtn.setAttribute("aria-label", "Increase zone attempts");
            zonePlusBtn.onclick = () => changeZoneAttempts(competitor.id, i, 1);

            zoneAttemptsControl.appendChild(zoneMinusBtn);
            zoneAttemptsControl.appendChild(zoneAttemptsInput);
            zoneAttemptsControl.appendChild(zonePlusBtn);

            zoneRow.appendChild(zoneButton);
            zoneRow.appendChild(zoneAttemptsControl);

            // Top row
            const topRow = document.createElement("div");
            topRow.className = "boulder-row";

            // Top checkbox
            const topGroup = document.createElement("div");
            topGroup.className = "checkbox-group";
            const topCheckbox = document.createElement("input");
            topCheckbox.type = "checkbox";
            topCheckbox.id = `top-${competitor.id}-${i}`;
            topCheckbox.checked = boulder.top;
            topCheckbox.setAttribute(
              "aria-label",
              `Top completed for boulder ${i + 1}`
            );
            topCheckbox.onchange = (e) =>
              updateCheckbox(competitor.id, i, "top", e.target.checked);

            const topLabel = document.createElement("label");
            topLabel.htmlFor = `top-${competitor.id}-${i}`;
            topLabel.textContent = "Top";
            topGroup.appendChild(topCheckbox);
            topGroup.appendChild(topLabel);

            // Top attempts control
            const topAttemptsControl = document.createElement("div");
            topAttemptsControl.className = "attempts-control";
            topAttemptsControl.setAttribute("role", "group");
            topAttemptsControl.setAttribute(
              "aria-label",
              `Top attempts for boulder ${i + 1}`
            );

            const topMinusBtn = document.createElement("button");
            topMinusBtn.textContent = "-";
            topMinusBtn.setAttribute("aria-label", "Decrease top attempts");
            topMinusBtn.onclick = () => changeTopAttempts(competitor.id, i, -1);

            const topAttemptsInput = document.createElement("input");
            topAttemptsInput.type = "number";
            topAttemptsInput.min = "1";
            topAttemptsInput.max = MAX_ATTEMPTS.toString();
            topAttemptsInput.value = boulder.topAttempts;
            topAttemptsInput.setAttribute(
              "aria-label",
              `Number of top attempts for boulder ${i + 1}`
            );
            topAttemptsInput.onchange = (e) =>
              updateTopAttempts(competitor.id, i, e.target.value);

            const topPlusBtn = document.createElement("button");
            topPlusBtn.textContent = "+";
            topPlusBtn.setAttribute("aria-label", "Increase top attempts");
            topPlusBtn.onclick = () => changeTopAttempts(competitor.id, i, 1);

            topAttemptsControl.appendChild(topMinusBtn);
            topAttemptsControl.appendChild(topAttemptsInput);
            topAttemptsControl.appendChild(topPlusBtn);

            topRow.appendChild(topGroup);
            topRow.appendChild(topAttemptsControl);

            controls.appendChild(zoneRow);
            controls.appendChild(topRow);
            boulderSection.appendChild(controls);

            // Score display
            const score = calculateBoulderScore(boulder);
            const scoreDiv = document.createElement("div");
            scoreDiv.className = "score";
            scoreDiv.textContent = `Score: ${score.toFixed(1)}`;
            scoreDiv.setAttribute(
              "aria-label",
              `Boulder ${i + 1} score: ${score.toFixed(1)} points`
            );
            boulderSection.appendChild(scoreDiv);

            boulderCell.appendChild(boulderSection);
            row.appendChild(boulderCell);
          }

          // Total score
          const totalCell = document.createElement("td");
          totalCell.setAttribute("data-label", "Total");
          totalCell.innerHTML = `<span class="total-score">${competitor.totalScore.toFixed(
            1
          )}</span>`;
          totalCell.setAttribute(
            "aria-label",
            `Total score: ${competitor.totalScore.toFixed(1)} points`
          );
          row.appendChild(totalCell);

          // Remove button
          const actionCell = document.createElement("td");
          actionCell.setAttribute("data-label", "Action");
          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-btn";
          removeBtn.textContent = "Remove";
          removeBtn.setAttribute(
            "aria-label",
            `Remove competitor ${competitor.name}`
          );
          removeBtn.onclick = () => removeCompetitor(competitor.id);
          actionCell.appendChild(removeBtn);
          row.appendChild(actionCell);

          fragment.appendChild(row);
        });

        // Clear and update tbody
        tbody.innerHTML = "";
        tbody.appendChild(fragment);

        // Remove loading state
        container.classList.remove("loading");
        isUpdating = false;
      }

      // Debounced version of updateDisplay for better performance
      const debouncedUpdateDisplay = debounce(updateDisplay, 100);

      function announceToScreenReader(message) {
        const announcement = document.createElement("div");
        announcement.setAttribute("aria-live", "polite");
        announcement.setAttribute("aria-atomic", "true");
        announcement.style.position = "absolute";
        announcement.style.left = "-9999px";
        announcement.textContent = message;
        document.body.appendChild(announcement);
        setTimeout(() => document.body.removeChild(announcement), 1000);
      }

      // Allow Enter key to add competitor
      document
        .getElementById("competitorName")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            addCompetitor();
          }
        });

      function showPodiumAnalysis() {
        const analysisDiv = document.getElementById("podiumAnalysis");
        const content = document.getElementById("analysisContent");

        if (competitors.length === 0) {
          showError("Please add competitors first");
          return;
        }

        // Toggle display
        if (analysisDiv.style.display === "none") {
          analysisDiv.style.display = "block";
          content.innerHTML = generatePodiumAnalysis();
        } else {
          analysisDiv.style.display = "none";
        }
      }

      function generatePodiumAnalysis() {
        try {
          // Calculate current scores and get current standings
          const competitorAnalysis = competitors.map((c) => {
            const currentScore = calculateTotalScore(c);
            const unattemptedBoulders = c.boulders.filter((b) => !b.attempted);
            const remainingBoulders = unattemptedBoulders.length;
            const maxPossibleScore =
              currentScore + remainingBoulders * TOP_SCORE;

            return {
              ...c,
              currentScore,
              remainingBoulders,
              unattemptedBoulders,
              maxPossibleScore,
            };
          });

          // Sort by current score to find current standings
          const currentStandings = [...competitorAnalysis].sort(
            (a, b) => b.currentScore - a.currentScore
          );

          // Add current position to each competitor
          competitorAnalysis.forEach((comp) => {
            comp.currentPosition =
              currentStandings.findIndex((c) => c.id === comp.id) + 1;
          });

          let html = "";

          // Sort by current position for display
          const sortedByPosition = [...competitorAnalysis].sort(
            (a, b) => a.currentPosition - b.currentPosition
          );

          sortedByPosition.forEach((competitor) => {
            const scenarios = analyzePodiumScenarios(
              competitor,
              competitorAnalysis,
              currentStandings
            );

            const positionSuffix =
              competitor.currentPosition === 1
                ? "st"
                : competitor.currentPosition === 2
                ? "nd"
                : competitor.currentPosition === 3
                ? "rd"
                : "th";

            html += `<div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 4px; border: 1px solid #ddd;">`;
            html += `<h3 style="margin-top: 0; color: #333;">${
              competitor.name
            } - Currently ${
              competitor.currentPosition
            }${positionSuffix} place (${competitor.currentScore.toFixed(
              1
            )} points)</h3>`;

            if (competitor.remainingBoulders === 0) {
              html += `<p style="color: #666;">All boulders attempted - final score: ${competitor.currentScore.toFixed(
                1
              )} points</p>`;
            } else if (scenarios.length === 0) {
              html += `<p style="color: #666;">Cannot reach podium - maximum possible score: ${competitor.maxPossibleScore.toFixed(
                1
              )} points</p>`;
            } else {
              html += `<ul style="margin: 0; padding-left: 20px;">`;
              scenarios.forEach((scenario) => {
                html += `<li style="margin-bottom: 8px; color: #333;">${scenario}</li>`;
              });
              html += `</ul>`;
            }

            html += `</div>`;
          });

          return html;
        } catch (error) {
          console.error("Error generating podium analysis:", error);
          return `<p style="color: #f44336;">Error generating analysis. Please try again.</p>`;
        }
      }

      function analyzePodiumScenarios(
        competitor,
        allCompetitors,
        currentStandings
      ) {
        const scenarios = [];
        const unattemptedBoulders = competitor.boulders
          .map((b, idx) => ({ boulder: b, index: idx }))
          .filter((item) => !item.boulder.attempted);

        if (unattemptedBoulders.length === 0) {
          return scenarios;
        }

        // Get scores needed for each podium position
        // We need to beat everyone above the position we want
        const scoresForPositions = {
          1: currentStandings[0]?.currentScore || 0, // Need to beat current 1st
          2: currentStandings[1]?.currentScore || 0, // Need to beat current 2nd (or equal if we're ok with 2nd=)
          3: currentStandings[2]?.currentScore || 0, // Need to beat current 3rd (or equal if we're ok with 3rd=)
        };

        // Check each podium position
        for (let position = 1; position <= 3; position++) {
          // Skip if already in this position
          if (competitor.currentPosition === position) {
            const competitorsAtSameScore = currentStandings.filter(
              (c) => Math.abs(c.currentScore - competitor.currentScore) < 0.01
            ).length;

            if (competitorsAtSameScore > 1) {
              scenarios.push(
                `Currently tied for ${position}${
                  position === 1 ? "st" : position === 2 ? "nd" : "rd"
                } place`
              );
            } else {
              scenarios.push(
                `Currently holding ${position}${
                  position === 1 ? "st" : position === 2 ? "nd" : "rd"
                } place`
              );
            }
            continue;
          }

          // For each position, we need to beat everyone currently ahead of that position
          // For 1st: beat current 1st
          // For 2nd: beat current 2nd (which means we'll be at least 2nd)
          // For 3rd: beat current 3rd (which means we'll be at least 3rd)
          const targetScore = scoresForPositions[position];

          // Check if it's even possible to reach this score
          if (competitor.maxPossibleScore <= targetScore) {
            continue; // Can't beat the score needed for this position
          }

          // Find paths to beat the target score
          const paths = calculateOptimalPaths(
            unattemptedBoulders,
            competitor,
            targetScore,
            position,
            true
          );

          if (paths.length > 0) {
            const positionName =
              position === 1 ? "1st" : position === 2 ? "2nd" : "3rd";
            paths.forEach((path) =>
              scenarios.push(`For ${positionName}: ${path}`)
            );
          }

          // Also check for equal positions
          if (competitor.maxPossibleScore >= targetScore) {
            const equalPaths = calculateOptimalPaths(
              unattemptedBoulders,
              competitor,
              targetScore,
              position,
              false
            );
            if (equalPaths.length > 0) {
              const positionName =
                position === 1 ? "1st=" : position === 2 ? "2nd=" : "3rd=";
              equalPaths.forEach((path) =>
                scenarios.push(`For ${positionName}: ${path}`)
              );
            }
          }
        }

        return scenarios;
      }

      function calculateOptimalPaths(
        unattemptedBoulders,
        competitor,
        targetScore,
        position,
        needToBeat
      ) {
        const paths = [];
        const boulderNumbers = unattemptedBoulders.map((b) => b.index + 1);

        // Calculate points needed
        const pointsNeeded = needToBeat
          ? targetScore - competitor.currentScore + 0.1 // Need to beat
          : targetScore - competitor.currentScore; // Need to equal

        // Double-check if achievable
        const maxPossibleFromRemaining = unattemptedBoulders.length * TOP_SCORE;
        if (pointsNeeded > maxPossibleFromRemaining || pointsNeeded <= 0) {
          return paths;
        }

        // Case 1: Single boulder scenarios
        if (pointsNeeded <= TOP_SCORE && unattemptedBoulders.length >= 1) {
          // Calculate attempts for a top (TOP_SCORE points minus deductions)
          // Score from top = TOP_SCORE - (attempts - 1) * ATTEMPT_DEDUCTION
          // So: attempts = ((TOP_SCORE - pointsNeeded) / ATTEMPT_DEDUCTION) + 1
          const attemptsForTop =
            Math.ceil((TOP_SCORE - pointsNeeded) / ATTEMPT_DEDUCTION) + 1;

          if (attemptsForTop >= 1 && attemptsForTop <= MAX_ANALYSIS_ATTEMPTS) {
            if (boulderNumbers.length === 1) {
              paths.push(
                `Complete Boulder ${
                  boulderNumbers[0]
                } top in ${attemptsForTop} attempt${
                  attemptsForTop > 1 ? "s" : ""
                }`
              );
            } else {
              paths.push(
                `Complete any 1 top in ${attemptsForTop} attempt${
                  attemptsForTop > 1 ? "s" : ""
                }`
              );
            }
          } else if (attemptsForTop > MAX_ANALYSIS_ATTEMPTS && needToBeat) {
            // If we need to beat and it's achievable with any number of attempts
            if (boulderNumbers.length === 1) {
              paths.push(`Complete Boulder ${boulderNumbers[0]} top`);
            } else {
              paths.push(`Complete any 1 top`);
            }
          }
          // Don't show equal placing options if it requires more than 20 attempts

          // Check if just a zone would work
          if (pointsNeeded <= ZONE_SCORE) {
            const attemptsForZone =
              Math.ceil((ZONE_SCORE - pointsNeeded) / ATTEMPT_DEDUCTION) + 1;
            if (
              attemptsForZone >= 1 &&
              attemptsForZone <= MAX_ANALYSIS_ATTEMPTS
            ) {
              paths.push(
                `Get 1 zone in ${attemptsForZone} attempt${
                  attemptsForZone > 1 ? "s" : ""
                }`
              );
            } else if (attemptsForZone > MAX_ANALYSIS_ATTEMPTS && needToBeat) {
              paths.push(`Get 1 zone`);
            }
          }
        }

        // Case 2: Multiple boulder scenarios
        if (pointsNeeded > ZONE_SCORE && unattemptedBoulders.length >= 2) {
          const topsNeeded = Math.ceil(pointsNeeded / TOP_SCORE);

          if (topsNeeded <= unattemptedBoulders.length) {
            // Calculate average attempts allowed
            const totalScoreFromTops = topsNeeded * TOP_SCORE;
            const allowedDeduction = totalScoreFromTops - pointsNeeded;
            const avgAttemptsPerTop =
              Math.floor(allowedDeduction / (topsNeeded * ATTEMPT_DEDUCTION)) +
              1;

            if (
              avgAttemptsPerTop >= 1 &&
              avgAttemptsPerTop <= MAX_ANALYSIS_ATTEMPTS
            ) {
              const boulderList = boulderNumbers
                .slice(0, topsNeeded)
                .join(", ");
              if (topsNeeded === unattemptedBoulders.length) {
                paths.push(
                  `Complete all ${topsNeeded} remaining tops averaging ${avgAttemptsPerTop} attempt${
                    avgAttemptsPerTop > 1 ? "s" : ""
                  } each`
                );
              } else {
                paths.push(
                  `Complete ${topsNeeded} tops (e.g., Boulders ${boulderList}) averaging ${avgAttemptsPerTop} attempt${
                    avgAttemptsPerTop > 1 ? "s" : ""
                  } each`
                );
              }
            } else if (
              avgAttemptsPerTop > MAX_ANALYSIS_ATTEMPTS &&
              needToBeat
            ) {
              const boulderList = boulderNumbers
                .slice(0, topsNeeded)
                .join(", ");
              if (topsNeeded === unattemptedBoulders.length) {
                paths.push(`Complete all ${topsNeeded} remaining tops`);
              } else {
                paths.push(
                  `Complete ${topsNeeded} tops (e.g., Boulders ${boulderList})`
                );
              }
            }
          }
        }

        return paths.slice(0, 2); // Return most relevant paths
      }

      // Initial display update
      updateDisplay();

      // Error handling for uncaught errors
      window.addEventListener("error", function (event) {
        console.error("Application error:", event.error);
        showError(
          "An unexpected error occurred. Please refresh the page if problems persist."
        );
      });
    </script>
  </body>
</html>
